---
title: "Data Analysis - Exercice Sheet 1"
author: "Carl Herrmann, Maïwen Caudron-Herger"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  markdown: 
    wrap: sentence
---

```{r knitr_init, echo=FALSE, cache=FALSE}
library(knitr)
library(rmdformats)
## Global options
options(max.print=200)
opts_chunk$set(echo=TRUE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=150)
```

# 1. Objectives

In this practical session you will

-   learn to use RStudio
-   learn how to implement some of the ideas taught in the first lesson using the R programming language.

Throughout this course we will use a common **diabetes dataset** to practically implement the concepts taught during the lectures.

Our dataset has various pathophysiological measurements of \> 400 individuals.
Clinical parameters like blood glucose levels, cholesterol levels, age, body size, weight, blood pressure etc have been measured.
We will use this dataset to explore the statistical properties of each variable (like its distribution, mean value etc) and question relations between variables (like is blood glucose level correlated with obesity?).

# 2. Lets get started - Load the data

The diabetes dataset, which we will be using throughout this practical will be downloaded from an online repository.
We will load that into R and have a sneak peek into how it looks like with the console.
In the following you will see several functions that give us information about our dataset.
You will also see how the "\$" sign is used to access specific columns of out dataframe.

```{r}
dat = read.delim('https://tinyurl.com/y4fark9g') # Load the dataset
head(dat, 10) # Look at the first 10 lines of the table
```

In your RStudio "Environment", you should see a variable with the name "dat".
If you click on it, it will open this variable, that is a data.frame.

### Lets explore and understand our dataset more

**1.** What is the dimension of our dataset (i.e. how many rows/columns are there in our data)

```{r}
# Dimension
dim(dat)
```

```{r, results='hide'}
# Number of columns
ncol(dat)
# Number of rows
nrow(dat)
```

**2.** What are the column names of our dataset

```{r}
colnames(dat) # Similarly rownames() for rows
```

Probably you are confused about what these column names mean.
For more description on these values [look here](https://biostat.app.vumc.org/wiki/pub/Main/DataSets/Cdiabetes.html)

**3.** How do we extract the minimum and maximum age of patients in our dataset

```{r, results='hide'}
min(dat$age)
max(dat$age)
range(dat$age)
```

> Can you find out the same for height and weight?

**4.** How does the overall summary of our entire dataset look like?

```{r rows.print=10}
summary(dat)
```

> Can you explain what you see?

Before we keep going, here is a quick reminder of how indexing and slicing works in R.
If you're already familiar with it you can skip the next chunk.

```{r eval = FALSE}

# Returning a specific column or line of a data structure
dat[1,] # Returns the first line
dat[,1] # Returns the first column
dat[1,1] # Returns only the first object of the first line


# Returning an interval of columns or lines of a data structure 
dat[1:3,] # Returns the first three lines
dat[,1:3] # Returns the first three columns
dat[1:3,1:3] # Returns the first three elements of the first three lines

# Returning a value or an interval of values in a vector
dat$age[1] # Returns the first value
dat$age[1:3] # Returns the first three values

```

Feel free to play around with this syntax until you feel comfortable with it.
You can open a window with `View(dat)` to compare your results.

# 3. Data cleanup

Very often the first thing one needs to do before any data science project is to clean up the raw data and transform it into a format that is readily understood and easy to use for all downstream analysis.
This process usually involves --

-   Removing empty value rows/columns
-   Removing unused or unnecessary rows/columns
-   Reordering the data matrix
-   Keeping columns uniformly numeric (age, weight etc) or string (names, places etc) or logical (TRUE/FALSE, 1/0)
-   Handling strange caveats which are data specific like replacing `,` or `.`, or `;` from numbers etc

Lets do some clean up of our own diabetes data

1.  We will make the `id` column the row names for the dataset.
2.  We will remove the `bp.2s` and `bp.2d` columns as it has mostly missing values (see summary above)
3.  We will also remove the column `time.ppn` which will not be required in our analysis
4.  We will reorder the columns of the data such that all the qualitative and quantitative values are separated. Among the quantitative values we will keep related variables together

To perform this cleanup, we need a couple of important functions, that we will first discuss.
If you went through "00_Advanced_Data_Manipulation_in_R.Rmd" from last week, you might already be familiar with some of these functions:

-   `which`
-   `apply`
-   `is.na`
-   `%in%`

## which

`which()` is used on a data structure and generates a data structure with the positions of the values that satisfy a condition you specify.
Let's look at an example.

```{r, eval = TRUE}
# Let's create a vector
Points = c(1,4,5,2,6,3,5,2)
# Let's use our function now
which(Points > 3)

```

This is very useful, but we can go one step further, by selecting values from a different vector, like this.

```{r, eval = TRUE}
# Let's create a different vector (of the same length)
Players = c("Anna", "Benedict", "Carlos", "David", "Emmanuel", "Franziska", "Gerard", "Hannah")
# Let's use the "which()" function now
Players[which(Points > 3)]

```

See?
We selected all names form the "Players" vector that correspond to more than three points in the "Points" vector. 
The type of condition can also vary, depending also on the data type in your dataset.
Just remember that it must have a **boolean** output (TRUE/FALSE) to be used in `which()`, e.g. `is.na()` (see below) can be used inside a `which()` function.

## apply

`apply()` is used to apply a function to an entire dataset at once and outputs a vector of results.
Later, we will use it like this:

```{r eval = FALSE}
rmv.rows = apply(dat, 1,function(x) {sum(is.na(x))})
```

But let's see it used on something more simple:

```{r eval = FALSE}
Mat = matrix(data = c(2,4,7,1,6,3,9,5,3), ncol = 3, nrow = 3) # Create a matrix
Mat
apply(Mat, 1, function(x) {sum(x)}) # Calculate the sum of each row
apply(Mat, 2, function(x) {mean(x)}) # Calculate the mean of each column
```

## is.na

As the name indicates, `is.na()` tells us if a value is a missing value (represented by `NA`) or not.

```{r}
x = 2
is.na(x)

y = NA
is.na(y)
```

We can do this with vectors:

```{r}
is.na(dat$glyhb)
```

> Understand how it works?

This is a vector of **logical** (or boolean) values.
Let's go one step further:

```{r}
sum(is.na(dat$glyhb))
```

What just happened?
Because we have used the `sum()` function, R has transformed `TRUE` into `1` and `FALSE` into `0`...

## %in%

This is an operator to check which elements of a first vector are inside a second vector

```{r}
c('a','b','e') %in% c('a','b','c','d','f')
```

You can also combine that with `which()`

```{r}
which(c('a','b','e') %in% c('a','b','c','d','f'))
```

## Ready for doing the cleanup!!

The first column of the dataframe is the column with the name "id".
The rows are just numbered, without names.
We are going to rename the rows using the column "id".

```{r}
# set the row names using the column id
rownames(dat) = dat$id
```

Now, we remove some columns: first, we determine which column index corresponds to the column names id, bp.2s, bp.2d and time.ppn

```{r}
i.remove = which(colnames(dat) %in% c("id","bp.2s", "bp.2d", "time.ppn"))
i.remove
# The function which returns the numbers of the columns with the given names.
# The first column has the name "id"
# the 15th column has the name "bs.2s"  etc ... 
```

Now, we remove these columns, using the "-" sign:

```{r}
dat = dat[, -i.remove]
# This will remove the columns with the indexes 1, 15, 16 and 19 (which are stored in the variable "i.remove", see above)
```

We re-order the remaining columns, in order to put the categorical columns first, and numerical columns after:

```{r}
dat = dat[,c(8,6,11,9,10,14,15,2,5,1,3,4,12,13)]
```

Now lets look at our cleaned data:

```{r}
summary(dat)
```

The ordering and selection of columns looks right, however it seems that there are certain rows that have missing values (like `glyhb` column has 13 `NA` values).
Lets remove all rows with any missing value: We go through each row and sum up all missing values (NA values).
Remember, 1 row = 1 patient.
For example, the 8th row (Patient with the number 1015) has a missing value in the column "bp.1s".
For this patient and column, the function `is.na()` will return the value "TRUE".

```{r}
is.na(dat[8,"bp.1s"])
```

If you sum up "TRUE" values, each counts like a 1.
For example, TRUE + TRUE = 2.
Therefore, it is possible to use the function `sum()` on the result of the function `is.na()` applied on each row of the dataframe "dat".

For the first row alone, this would be obtained like this:

```{r}
sum(is.na(dat[1,]))
# This is calculating the number of NAs in the first row of the table "dat".

# The result is 0 because there are no NA on this line.
# Check out the result here:
dat[1,]

# The function is.na() returns only FALSE for each column of the first line.
is.na(dat[1,])
```

Now, we would like to repeat the same for each patient, i.e. for each line.
This could be performed by a **for loop**, but there is a function for this kind of repetitive processes on either rows or columns.
We are going to use the function `apply()`.
`apply()` is used with the parameter 1 for rows and the parameter 2 for columns.
Since we'd like to calculate the number of NAs per row, we use the parameter 1 in the functions.
The sum of NAs is stored in the variable rmv.rows - our next aim being to remove those rows with NAs.

```{r}
rmv.rows = apply(dat, 1, function(x) {sum(is.na(x))}) 
```

"rmv.rows" is a vector containing the number of NAs for each row.

> What should be the expected length of this vector?
> Think about the dimensions of the dataframe "dat"

What are the number of missing values for the first rows?
We can use for this the function `head()`.

```{r}
head(rmv.rows)
```

Next, we'd like to determine the index of the rows containing missing values.
For these rows, the variable rmv.rows will have values \> 0.
Correct?
Again, we can use the function `which()` for this task.

```{r}
i.missing = which(rmv.rows >0) # This is returning the index of the rows with 1 or more missing values.
head(i.missing)
```

Accordingly, patient 1015 (8th row) has missing values.

```{r}
# You can type the following to check:
dat["1015",]
# or
sum(is.na(dat["1015",]))
# 2 missing values for this patient!
```

Now, we can remove the patients with missing values.
We proceed as before and use the "-" sign:

```{r}
dat = dat[-i.missing,] 
```

> How many patients were removed because they were associated with missing values?

Now our cleaned data has no missing values, columns are cleanly ordered and each column is in the right format

```{r}
summary(dat)
```

> Can you identify which types of data (continuous, discrete etc) each column above represents and why?

# 4. Visualizing data distribution

In this section you will learn the essential functions to plot data in an intuitive and useful way.

### Histograms

We can plot the column "stab.glu" as a histogram using the `hist()` function:

```{r eval = TRUE}
hist(dat$stab.glu, xlab ="Stabilized Glucose concentration in blood", main ="Glucose concentration")
```

Remember that you can type `help("hist")` in the Console to see more details about the histogram function in R.

> Add the parameter `breaks = 50` in the above lines of code and see what happens.
> Try different values for `breaks` like `10, 20, 75, 100` and try to interpret the differences.
> Is this a good or bad thing about histograms in general?

### Density plots

For density plots, we use the `density()` function to estimate the probability density function for a given variable.
With its return value, we can build the final density plot using the `plot()` function:

```{r eval = TRUE}
d <- density(dat$stab.glu)
plot(d, xlab ="Stabilized Glucose concentration in blood", main ="Glucose concentration")
```

### Boxplots

The `boxplot()` function produces a boxplot for a given variable:

```{r eval = TRUE}
boxplot(dat$stab.glu, xlab ="Stabilized Glucose concentration in blood", horizontal = TRUE)
```

> Can you explain all features of this graph, such as upper/lower whisker, 25% quantile, ...?

### QQ-plots

As discussed in the lecture, we can use **QQ-plots** to either (1) compare two distributions, or (2) compare a distribution with a theoretical distribution (typically the normal distribution).

We can for example compare the distribution of the blood pressure values to check if they are normally distributed

```{r eval=TRUE}
## Let's first make a histogram
hist(dat$bp.1s)

## Maybe with more bins?
hist(dat$bp.1s,breaks = 20)
```

Now we can use the function `qqnorm()` to generate the **QQ-plot** of this distribution against the standard normal distribution:

```{r eval = TRUE}
qqnorm(dat$bp.1s)
```

Using the additional command `qqline()`, we can add a straight line that goes through the first and third quantiles:

```{r eval = TRUE}
qqnorm(dat$bp.1s); qqline(dat$bp.1s)
```

> So, is the distribution normal??

Now let's compare the quantiles of the cholesterol values of men and women!

```{r eval = TRUE}
# We can use "which()" to select the cholesterol values for men and women

rows.men = which(dat$gender == 'male') # positions of male patients
rows.women = which(dat$gender == 'female')

bp.men = dat$bp.1s[rows.men] # select all values from the "bp.1s" column that correspond to male patients 
bp.women = dat$bp.1s[rows.women]

# Compute the quantiles (note the "na.rm" option to ignore missing NA values!)
q.men = quantile(bp.men, probs=seq(0,1,by=0.05), na.rm=TRUE)
q.women = quantile(bp.women, probs=seq(0,1,by=0.05), na.rm=TRUE)

# Now plot against each other!
plot(q.men, q.women, pch=20)
```

### Going further: making fancy plots!

You don't have to understand the code below in detail.
Instead, you can just check the resulting plot.
If you have questions, use `help()` for further information on a specific function or let us know.

```{r, eval=TRUE}
library(vioplot)
# Note: if you'd like to use specific functions, which are not available in the R Base Package or other packages uploaded per defaults, you will need to download and "activate" specific packages. 
# To download a specific function "xxx", you can use the function `install.packages("xxx")`. In this case, you can type install.packages("vioplot") in the console. If you have questions about it, let us know.
# library(xxx) is then used to activate a specific package "xxx".

layout(matrix(c(1:3)))

par(mar=c(0,4,0.5,0.5), mgp=c(2.8,0.5,0), las=2)
hist(dat$stab.glu, xlab ="", main = "", freq = F, ylim=c(0,0.035), xlim=c(0,400), xaxt="n", breaks="FD")
box();lines(density(dat$stab.glu), col="green", lwd=2)
abline(v=summary(dat$stab.glu)[2:5], col = c("blue", "red", "black", "orange"), lty=2)

par(mar=c(0,4,0,0.5), mgp=c(2.8,0.5,0), las=2, xaxt="n", yaxt="n")
vioplot(dat$stab.glu,horizontal = T, ylim=c(0,400), names = "", col="white")
abline(v=summary(dat$stab.glu)[2:5], col = c("blue", "red", "black", "orange"), lty=2)

par(mar=c(4,4,0,0.5), mgp=c(2.8,0.5,0), las=2, xaxt="s", yaxt="s")
boxplot(dat$stab.glu, xlab ="Stabilized Glucose concentration in blood", horizontal = T, ylim=c(0,400))
abline(v=summary(dat$stab.glu)[2:5], col = c("blue", "red", "black", "orange"), lty=2)
```

> Which do you think is a better plot for visualizing data distribution?
> What are the advantages and disadvantages of each of these plots?

Once again, we are looking at a lot of new functions.
`hist()`, `plot()`, `vioplot()` and `boxplot()` all serve to visualize data in different ways.
Make sure you understand how to read them, use the lecture material if you have difficulties.
The `par()` function, which is short for "parameters", is an often recurring function that sets graphic parameters such as font size, margins size, colors etc. for the following plots.
Try to learn more about it with `help("par")` and then try plotting the same data with different parameters.
Regardless of what you are plotting, `par()` will always help you get the plot you want!

# Exercises

#### Exercise 1

1.  Try to obtain the same result of the `head()` function by using slicing on the dataset "dat".

2.  Print out the first three column names of "dat" using `colnames()`.

3.  Print out the last element in the last column of "dat" using the `dim()` function instead of using numerals.

```{r}
#### SOLUTION

# 1.
dat[1:6,]  # shows the first 6 rows

# 2. 
colnames(dat)[1:3]
# or
colnames(dat)[c(1,2,3)]

# 3.
dat[dim(dat)[1],dim(dat)[2]]
# or
dat[nrow(dat),ncol(dat)]

```

#### Exercise 2

1.  Write a code to calculate the mean of each line of the matrix "Mat" without using the `mean()` function and print out the result. Use the `apply()` function.

```{r}
Mat = matrix(data = c(2,4,7,1,6,3,9,5,3), ncol = 3, nrow = 3)
```

2.  Add one line of code that prints out the results from exercise 1 that are greater than 4.5 by using the `which()` function.

```{r}
#### SOLUTION

# 1.
apply(Mat,1,function(x) {sum(x)/length(x)})

# 2. 
i.top = which(Mat>4.5)
Mat[i.top]
# or
i.top = which(Mat>4.5,arr.in=TRUE) # returns arrays indices i.e. rows/columns
Mat[i.top]
```

#### Exercise 3

1.  Visualize the cholesterol levels of all patients with a histogram using the `hist()` function.

2.  Visualize the cholesterol levels of all **male** patients with a histogram using `hist()`. 
    *(expert):* Mark the median, first and third quartile with lines using `abline()`.
    Then mark median, first and third quartile for **female** patients in the same graph with a different color.
    What can you tell from the differences in these values?

3.  Use the `qqplot()` function to plot waist against hip, height against hip and chol against hip in a QQ-plot.
    Can you correctly interpret these plots?
    How are those distributions different?

```{r}
#### SOLUTION

# 1.
hist(dat$chol)

# 2.
# we can split the data frame into male/female patients
dat.male = dat[dat$gender == 'male',]
dat.female = dat[dat$gender == 'female',]

# calculate the median, first and third quantile for male/female patients
q.male = quantile(dat.male$chol,probs=c(0.25,0.5,0.75)) 
q.female = quantile(dat.female$chol,probs=c(0.25,0.5,0.75))

#plot the histogram of male patients and add lines for male and female patients
hist(dat.male$chol,breaks=20);abline(v=q.male,lwd=2,lty=3,col='blue');abline(v=q.female,lwd=2,lty=3,col='red')

# 3.
qqplot(dat$waist,dat$hip)

qqplot(dat$height,dat$hip)

qqplot(dat$chol,dat$hip)
```
